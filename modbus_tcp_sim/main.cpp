//***************************************************************************
//                          main.cpp  -  description
//                             -------------------
//  begin            : Mo. Aug 8 12:23:57 2011
//  generated by     : pvdevelop (C) Lehrig Software Engineering
//  email            : lehrig@t-online.de
//***************************************************************************
// ModbusTcpSimulate_and_Serve
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "rlmodbus.h"
#include "rlthread.h"
#include "rlinifile.h"
#include "rlstring.h"
#include "rltime.h"

static int running             = 1;
static int show_request        = 1;
static int show_response       = 1;
static int show_read_requests  = 1;
static int show_write_requests = 1;
static int transactionID;
rlModbus  *mtty     = NULL;
rlModbus  *mtcp     = NULL;
rlSerial  *tty      = NULL;
rlSocket  *mysocket = NULL;
rlIniFile *ini      = NULL;
rlString   inifilename;
rlMutex    mutex;

static int send_back_response(int slave, int function, unsigned char *data, int len)
{
  int ret;
  unsigned char buf[16];

  if(len > 0 && mysocket->isConnected())
  {
    if(show_response) printf("response len=%d slave=%d function=%d data=%02x %02x %02x %02x\n", 
                                       len,   slave,   function,   data[0], data[1], data[2], data[3]);
    buf[0]  = (unsigned char) (transactionID & 0xFF00) / 256;
    buf[1]  = (unsigned char) (transactionID & 0xFF);
    buf[2]  = 0;
    buf[3]  = 0;
    buf[4]  = 0;
    buf[5]  = (unsigned char) 2 + len;  // 2+datalen = number of bytes which follow
    buf[6]  = (unsigned char) slave;
    buf[7]  = (unsigned char) function;
    buf[8]  = (unsigned char) len;      // datalen
    switch(function)
    {
      case rlModbus::ReadCoilStatus:
      case rlModbus::ReadInputStatus:
      case rlModbus::ReadHoldingRegisters:
      case rlModbus::ReadInputRegisters:
      case rlModbus::FetchCommEventLog:
      case rlModbus::ReportSlaveID:
      case rlModbus::ReadGeneralReference:
      case rlModbus::WriteGeneralReference:
      case rlModbus::ReadWrite4XRegisters:
        ret  = mysocket->write(buf,9);
        ret += mysocket->write(data,len);
        return ret;
      case rlModbus::ForceSingleCoil:
      case rlModbus::PresetSingleRegister:
      case rlModbus::FetchCommEventCtr:
      case rlModbus::ForceMultipleCoils:
      case rlModbus::PresetMultipleRegs:
        ret  = mysocket->write(buf,8);
        ret += mysocket->write(data,len);
        return ret;
      case rlModbus::ReadExceptionStatus:
        ret  = mysocket->write(buf,8);
        ret += mysocket->write(data,len);
        return ret;
      case rlModbus::MaskWrite4XRegisters:
        ret  = mysocket->write(buf,8);
        ret += mysocket->write(data,len);
        return ret;
      case rlModbus::ReadFifoQueue:
        ret  = mysocket->write(buf,8);
        ret += mysocket->write(data,len);
        return ret;
      default:
        return -1;
    }
  }
  return -1;
}

// ### ModbusTcpSimulation begin  #########################################
static void fillDataFromIni(int slave, int start_adr, int byte_count, unsigned char *data)
{ // read data from ini
  int i, val;
  char sname[80],adr[80];
  const char *cptr, *start;

  mutex.lock();
  data[0] = byte_count;
  for(i=0; i<byte_count; i++) data[i+1] = 0;
  sprintf(sname,"SLAVE_%d", slave);
  sprintf(adr,"read0x0%04x", start_adr);
  start = cptr = ini->text(sname,adr);
  if(cptr == NULL) return;
  for(i=0; i<byte_count; i++)
  {
    if(*cptr == '\0') break;
    sscanf(cptr,"%02x", &val);
    data[i+1] = (unsigned char) val;
    cptr++;
    if(*cptr == '\0') break;
    cptr++;
    if(*cptr == '\0') break;
    cptr++;
    if(*cptr == '\0') break;
  }
  mutex.unlock();
  if(show_read_requests) printf("fillDataFromIni:: slave=%d %s data=%s\n", slave, adr, start);
}

static void putDataToIni(int slave, int start_adr, int byte_count, unsigned char *data)
{ // write data to ini
  char slavename[80],name[80], val[80], buf[4096];
  
  sprintf(slavename, "SLAVE_%d",     slave);
  sprintf(name,      "write0x0%04x", start_adr);

  buf[0] = '\0';
  for(int i=0; i<byte_count; i++)
  {
    sprintf(val, "%02x ", data[i]);
    strcat(buf, val);
  }

  ini->printf(slavename,name,"%s",buf);
  if(show_write_requests) printf("putDataToIni::    slave=%d %s data=%s\n", slave, name, buf);
}

static void *exec_ModbusSimulationThread(void *arg)
{
  int i, len, slave, function, start_adr, num_register, byte_count;
  unsigned char data[1024];
  rlTime t, last;

  byte_count = 0;
  last.getFileModificationTime(inifilename.text());
  while(running)
  {
    if(mysocket->isConnected() == 0)
    {
      printf("waiting for client on port=%d\n", mysocket->getPort());
      mysocket->connect(); // wait for client
      printf("client has connected\n");
    }  
    len = mtcp->readRequest(&slave, &function, data, 1000, &transactionID); 
    if(len >= 4)
    {
      start_adr = data[0]*256 + data[1];
      num_register = data[2]*256 + data[3];
      if(show_request)
      {
        if(show_request) 
        {
          printf("request slave=%03d function=%02d start_adr=%04x num_register=%03d data=", 
                          slave,     function,     start_adr,     num_register);
          for(i=0; i<len; i++) printf("%02x ", data[i]);
          printf("\n");
        }  
      }  
      t.getFileModificationTime(inifilename.text());
      if(t == last)
      {
      }
      else
      {
        mutex.lock();
        printf("read ini file %s\n", inifilename.text());
        ini->read(inifilename.text());
        show_request        = atoi(ini->text("OPTIONS","SHOW_REQUEST"));
        show_response       = atoi(ini->text("OPTIONS","SHOW_RESPONSE"));
        show_read_requests  = atoi(ini->text("OPTIONS","SHOW_READ_REQUESTS"));
        show_write_requests = atoi(ini->text("OPTIONS","SHOW_WRITE_REQUESTS"));
        mutex.unlock();
        last = t;
      }  
      switch(function)
      {
        case rlModbus::ReadCoilStatus:
        case rlModbus::ReadInputStatus:
          byte_count = num_register/8 + 1;
          fillDataFromIni(slave, start_adr, byte_count, data);
          mtcp->write(slave, function, data, byte_count + 1, &transactionID);
          break;
        case rlModbus::ReadHoldingRegisters:
        case rlModbus::ReadInputRegisters:        
          byte_count = num_register*2;
          fillDataFromIni(slave, start_adr, byte_count, data);
          mtcp->write(slave, function, data, byte_count + 1, &transactionID);
          break;
        case rlModbus::ForceSingleCoil:
        case rlModbus::PresetSingleRegister:
          putDataToIni(slave, start_adr, 2, &data[2]);
          mtcp->write(slave, function, data, 4, &transactionID); // echo back set values
          break;
        case rlModbus::ReadExceptionStatus:
        case rlModbus::FetchCommEventCtr:
        case rlModbus::FetchCommEventLog:
        case rlModbus::ReportSlaveID: 
          byte_count = 0;
          fillDataFromIni(slave, start_adr, byte_count, data);
          mtcp->write(slave, function, data, byte_count, &transactionID);
          break;
        case rlModbus::ForceMultipleCoils:
        case rlModbus::PresetMultipleRegs:
          byte_count = data[0];
          putDataToIni(slave, start_adr, byte_count, &data[1]);
          data[0] = (num_register / 256) & 0x0ff;
          data[1] = num_register & 0x0ff;
          mtcp->write(slave, function, data, 2, &transactionID); // echo back num affected
          break;
        case rlModbus::ReadGeneralReference:
        case rlModbus::WriteGeneralReference:
        case rlModbus::MaskWrite4XRegisters:
        case rlModbus::ReadWrite4XRegisters: 
        case rlModbus::ReadFifoQueue:
          printf("ERROR: function code %d currently not implemented in simulator\n", function);
          break;
        default:
          printf("ERROR: unknown function code %d\n", function);
          break;
      }
    }
  }
  return arg;
}

static int exec_ModbusSimulation()
{
  char line[80];
  rlThread thread;

  printf("you may use the following commands:\n");
  printf("r   - read ini file again (modbus variables are read from there)\n");
  printf("w   - write ini file (modbus variables are listed there)\n");
  printf("q   - quit simulation\n");
  thread.create(exec_ModbusSimulationThread, NULL);
  while(1)
  {
    fgets(line, sizeof(line)-1, stdin);
    if(line[0] == 'q')
    {
      break;
    }
    else if(line[0] == 'r')
    {
      mutex.lock();
      printf("read ini file %s\n", inifilename.text());
      ini->read(inifilename.text());
      show_request        = atoi(ini->text("OPTIONS","SHOW_REQUEST"));
      show_response       = atoi(ini->text("OPTIONS","SHOW_RESPONSE"));
      show_read_requests  = atoi(ini->text("OPTIONS","SHOW_READ_REQUESTS"));
      show_write_requests = atoi(ini->text("OPTIONS","SHOW_WRITE_REQUESTS"));
      mutex.unlock();
    }
    else if(line[0] == 'w')
    {
      mutex.lock();
      printf("write ini file %s\n", inifilename.text());
      ini->write(inifilename.text());
      mutex.unlock();
    }
    else if(line[0] >= 'a')
    {
      printf("you may use the following commands:\n");
      printf("r   - read ini file again (modbus variables are read from there)\n");
      printf("w   - write ini file (modbus variables are listed there)\n");
      printf("q   - quit simulation\n");
    }
  }
  running = 0;
  thread.cancel();
  return 0;
}
// ### ModbusTcpSimulation end  #########################################

// ### ModbusTcpServe gateway to tty begin ##############################
static void *exec_ModbusTcpServerThread(void *arg)
{
  int len, slave, function;
  unsigned char data[1024];

  while(running) // read the response from the modbus device at the tty
  {              // and send it to tcp
    len = mtty->response(&slave, &function, data);
    send_back_response(slave, function, data, len);
  }
  return arg;
}

static int exec_ModbusTcpServer()
{
  int ret, len, slave, function;
  unsigned char data[1024];
  const char *cptr;
  rlThread thread;

  thread.create(exec_ModbusTcpServerThread, NULL);
  while(1)
  {
    mysocket->connect(); // wait for client
    if(mysocket->isConnected())
    {
      tty->readBlock(data,sizeof(data)-1,100); // clear eventually pending char in tty
      printf("Client connected to ModbusTcpServer ClientIpAdr=%d.%d.%d.%d\n",
             mysocket->sockaddr[4],
             mysocket->sockaddr[5],
             mysocket->sockaddr[6],
             mysocket->sockaddr[7]);
      cptr = ini->text("TCP","ALLOWED_CLIENT");
      if(isdigit(*cptr))
      {
         int a1,a2,a3,a4, test;
         sscanf(cptr,"%d.%d.%d.%d", &a1, &a2, &a3, &a4);
         test = 0;
         if(a1 != mysocket->sockaddr[4]) test++;
         if(a2 != mysocket->sockaddr[5]) test++;
         if(a3 != mysocket->sockaddr[6]) test++;
         if(a4 != mysocket->sockaddr[7]) test++;
         if(test == 0)
         {
           printf("Client is allowed to connect\n");
         }
         else
         {
           mysocket->disconnect();
           printf("Client is not allowed to connect\n");
         }
      }
      else
      {
        printf("Any client is allowed to connect. This is insecure !!!. Please set ALLOWED_CLIENT within the ini file\n");
      }
      while(mysocket->isConnected())
      {
        len = mtcp->readRequest(&slave, &function, data, 1000, &transactionID); 
        if(len > 0)
        {
          //printf("request  len=%d slave=%d function=%d data=%02x %02x %02x %02x\n",
          //                 len,   slave,   function,   data[0], data[1], data[2], data[3]);
          ret = mtty->write(slave, function, data, len, &transactionID);
        }
      }
      printf("Client disconnected from ModbusTcpServer\n");
    }
  }
  running = 0;
  thread.cancel();
  return 0;
}
// ### ModbusTcpServe gateway to tty end ######################################

// ### ModbusTcpSimulate_and_Serve main() #####################################
int main(int ac, char **av)
{
  int ret, port;
  const char *inifile, *ttyname, *baudrate;
  if(ac < 2) inifile = "mtss.ini";
  else       inifile = av[1];

  inifilename = inifile;
  ini = new rlIniFile();
  if(ini->read(inifile) < 0)
  {
    printf("could not read inifile %s\n", inifile);
    return -1;
  }
  ttyname  = ini->text("TTY","NAME");
  baudrate = ini->text("TTY","BAUDRATE");
  port     = atoi(ini->text("TCP","PORT"));
  printf("tty=%s baudrate=%s port=%d\n", ttyname, baudrate, port);
  show_request        = atoi(ini->text("OPTIONS","SHOW_REQUEST"));
  show_response       = atoi(ini->text("OPTIONS","SHOW_RESPONSE"));
  show_read_requests  = atoi(ini->text("OPTIONS","SHOW_READ_REQUESTS"));
  show_write_requests = atoi(ini->text("OPTIONS","SHOW_WRITE_REQUESTS"));
  mtcp   = new rlModbus();
  mysocket = new rlSocket("localhost",port,0);
  mtcp->registerSocket(mysocket);
  if(strcmp(ttyname,"simulation") == 0)  // run ModbusTCP server as simulation
  {
    running = 1;
    printf("starting in simulation mode\n");
    ret = exec_ModbusSimulation();
    running = 0;
  }
  else                                   // run ModbusTCP to RS232/RS485 gateway 
  {
    mtty   = new rlModbus();
    tty    = new rlSerial();
    mtty->registerSerial(tty);
    int speed = B9600;
    if(strcmp(baudrate,"B300")    == 0) speed = B300;
    if(strcmp(baudrate,"B600")    == 0) speed = B600;
    if(strcmp(baudrate,"B1200")   == 0) speed = B1200;
    if(strcmp(baudrate,"B1800")   == 0) speed = B1800;
    if(strcmp(baudrate,"B2400")   == 0) speed = B2400;
    if(strcmp(baudrate,"B9600")   == 0) speed = B9600;
    if(strcmp(baudrate,"B19200")  == 0) speed = B19200;
    if(strcmp(baudrate,"B38400")  == 0) speed = B38400;
    if(strcmp(baudrate,"B57600")  == 0) speed = B57600;
    if(strcmp(baudrate,"B115200") == 0) speed = B115200;
    if(strcmp(baudrate,"B230400") == 0) speed = B230400;
    if(strcmp(baudrate,"B460800") == 0) speed = B460800;
    if(strcmp(baudrate,"B500000") == 0) speed = B500000;
    ret = tty->openDevice(ttyname,speed);
    if(ret < 0)
    {
      printf("could not open serial port %s\n", ttyname);
    }
    else
    {
      running = 1;
      printf("starting as ModbusTCP to RS232/RS485 gateway\n");
      ret = exec_ModbusTcpServer();
      running = 0;
    }  
  }
  if(mtty     != NULL) delete mtty;
  if(mtcp     != NULL) delete mtcp;
  if(tty      != NULL) delete tty;
  if(mysocket != NULL) delete mysocket;
  if(ini      != NULL) delete ini;
  return ret;
}

