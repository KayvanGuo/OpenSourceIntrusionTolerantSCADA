//***************************************************************************
//                          main.cpp  -  description
//                             -------------------
//  begin            : Do Jan 17 17:06:13 2008
//  generated by     : pvdevelop (C) 2000-2007 by Lehrig Software Engineering
//  email            : lehrig@t-online.de
//***************************************************************************

// include headers for socket management
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <unistd.h>
#include <netdb.h>
#include <netinet/in.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/time.h>

// include other headers
#include "pvapp.h"
#include "master_exec.h"

#define PORT 5555
// todo: comment me out. you can insert these objects as extern in your masks.
//rlModbusClient     modbus(modbusdaemon_MAILBOX,modbusdaemon_SHARED_MEMORY,modbusdaemon_SHARED_MEMORY_SIZE);
//rlSiemensTCPClient siemensTCP(siemensdaemon_MAILBOX,siemensdaemon_SHARED_MEMORY,siemensdaemon_SHARED_MEMORY_SIZE);
//rlPPIClient        ppi(ppidaemon_MAILBOX,ppidaemon_SHARED_MEMORY,ppidaemon_SHARED_MEMORY_SIZE);

int dad_sock;

void *DAD_connection(void *arg) {
  int o_sock, i;
  fd_set active_fd_set, read_fd_set;
  struct sockaddr_in dad_conn;
  struct timeval timeout;
  socklen_t size;

  if(arg != NULL)
    return NULL;

  // Create socket
  o_sock = socket(PF_INET, SOCK_STREAM, 0);
  if(o_sock < 0) {
    perror("Couldn't create a socket");
    exit(EXIT_FAILURE);
  }

  // Bind
  dad_conn.sin_family = AF_INET;
  dad_conn.sin_port = htons(PORT);
  dad_conn.sin_addr.s_addr = htonl(INADDR_ANY);
  if(bind(o_sock, (struct sockaddr *)&dad_conn, sizeof(dad_conn)) < 0) {
    perror("Bind failure");
    exit(EXIT_FAILURE);
  }

  // Listen
  if(listen(o_sock, 1) < 0) {
    perror("Listen error");
    exit(EXIT_FAILURE);
  }

  // Init data structures for select()
  FD_ZERO(&active_fd_set);
  FD_SET(o_sock, &active_fd_set);
  timeout.tv_sec = 0;
  timeout.tv_usec = 500000;
  dad_sock = -1;

  while(1) {
    // Handle incoming DAD connections and messages
    read_fd_set = active_fd_set;
    if(select(FD_SETSIZE, &read_fd_set, NULL, NULL, &timeout) > 0) {
      for(i = 0; i < FD_SETSIZE; i++) {
        if(FD_ISSET(i, &read_fd_set)) {
          if(i == o_sock) {
            if(dad_sock == -1) { // accept incoming connection only if there's no DAD connected yet
              size = sizeof(dad_conn);
              dad_sock = accept(o_sock, (struct sockaddr *)&dad_conn, &size);
              if(dad_sock < 0) {
                perror("Connection request refused");
                exit(EXIT_FAILURE);
              }
              FD_SET(dad_sock, &active_fd_set);
            }
          }
          else {
            if(Read_From_DAD(i) < 0) {
              close(i);
              FD_CLR(i, &active_fd_set);
            }
          }
        }
      }
    }
  }
}

int pvMain(PARAM *p) {
  int ret;

  pvSetCaption(p,"pvs");
  pvResize(p,0,1280,1024);
  //pvScreenHint(p,1024,768); // this may be used to automatically set the zoomfactor
  ret = 1;
  pvGetInitialMask(p);
  if(strcmp(p->initial_mask,"mask1") == 0) ret = 1;

  while(1) {
    switch(ret) {
      case 1:
        pvStatusMessage(p,-1,-1,-1,"mask1");
        ret = show_mask1(p);
        break;
      default:
        return 0;
    }
  }
}

#ifdef USE_INETD
int main(int ac, char **av) {
  PARAM p = NULL;

  pthread_t tid;
  pthread_create(&tid, NULL, &DAD_connection, NULL);

  pvInit(ac,av,&p);
  /* here you may interpret ac,av and set p->user to your data */
  pvMain(&p);
  return 0;
}
#else  // multi threaded server
int main(int ac, char **av) {
  PARAM p;
  int   s;

  pthread_t tid;
  pthread_create(&tid, NULL, &DAD_connection, NULL);

  pvInit(ac,av,&p);
  /* here you may interpret ac,av and set p->user to your data */
  while(1)
  {
    s = pvAccept(&p);
    if(s != -1) pvCreateThread(&p,s);
    else        break;
  }
  return 0;
}
#endif
